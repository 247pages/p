<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Jio Audio Pair — Broadcaster</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body{font-family:sans-serif;color:#eee;background:#111;padding:10px;text-align:center}
  video{width:95%;background:#000;height:180px}
  textarea{width:95%;height:80px;font-size:12px;margin-top:6px}
  button{padding:10px;margin:6px;width:95%}
  pre{white-space:pre-wrap;text-align:left;background:#222;padding:8px;border-radius:6px;height:120px;overflow:auto}
</style>
</head>
<body>
  <h2>Jio Audio Pair — Broadcaster (Camera)</h2>
  <video id="local" autoplay muted playsinline></video>
  <div>
    <button id="startCam">Start Camera</button>
    <button id="createOffer">Create Offer & Play (send via audio)</button>
  </div>
  <div><small>Then place Admin device near Jio microphone and have it listen.</small></div>
  <h4>Log</h4><pre id="log">Idle...</pre>
  <h4>Decoded remote answer (if received)</h4><textarea id="decodedAnswer" placeholder="Answer will appear here"></textarea>

<script>
/*
Audio-based simple modem prototype.
Encoding: hex nibbles 0..15 mapped to 16 frequencies.
Start marker: frequency set 0xFF played for marker duration.
Message flow: play start marker -> symbols -> end marker.
Receiver detects symbol per symbolDuration window.
*/

var logEl = document.getElementById('log');
function log(s){ logEl.innerText += "\n" + s; }

var localVideo = document.getElementById('local');
var decodedArea = document.getElementById('decodedAnswer');

var pc = null;
var localStream = null;

// --- Tone params ---
var baseFreq = 1200; // lowest tone
var freqStep = 200;  // step between tones (16 tones -> covers 1200..4200)
var symbolDuration = 140; // ms per symbol (increase for reliability)
var markerFreq = 5000; // special marker frequency (> others)
var sampleInterval = symbolDuration; // for receiver window

// create tone for nibble (0..15)
function nibbleFreq(n) {
  return baseFreq + (n * freqStep);
}

// UTF-8 string -> hex string
function strToHex(s) {
  var h = "";
  for (var i=0;i<s.length;i++){
    var code = s.charCodeAt(i);
    // encode as utf-8 multi-byte
    if (code < 0x80) {
      h += ("0" + code.toString(16)).slice(-2);
    } else if (code < 0x800) {
      // two bytes
      h += ("0" + (0xc0 | (code>>6)).toString(16)).slice(-2);
      h += ("0" + (0x80 | (code & 0x3f)).toString(16)).slice(-2);
    } else {
      h += ("0" + (0xe0 | (code>>12)).toString(16)).slice(-2);
      h += ("0" + (0x80 | ((code>>6)&0x3f)).toString(16)).slice(-2);
      h += ("0" + (0x80 | (code & 0x3f)).toString(16)).slice(-2);
    }
  }
  return h;
}

// hex string -> utf8 string
function hexToStr(hex) {
  var bytes = [];
  for (var i=0;i<hex.length;i+=2) bytes.push(parseInt(hex.substr(i,2),16));
  // decode utf-8
  var out = "";
  for (var i=0;i<bytes.length;i++) {
    var b = bytes[i];
    if ((b & 0x80) === 0) {
      out += String.fromCharCode(b);
    } else if ((b & 0xe0) === 0xc0) {
      var b2 = bytes[++i];
      out += String.fromCharCode(((b & 0x1f) << 6) | (b2 & 0x3f));
    } else {
      var b2 = bytes[++i];
      var b3 = bytes[++i];
      out += String.fromCharCode(((b & 0x0f)<<12) | ((b2 & 0x3f)<<6) | (b3 & 0x3f));
    }
  }
  return out;
}

// convert hex to nibble array
function hexToNibbles(hex) {
  var arr = [];
  for (var i=0;i<hex.length;i++){
    var nib = parseInt(hex[i],16);
    arr.push(nib);
  }
  return arr;
}

// play a tone sequence using WebAudio
function playTonesForNibbles(nibbles, onDone) {
  try {
    var ctx = new (window.AudioContext || window.webkitAudioContext)();
    var now = ctx.currentTime;
    var gain = ctx.createGain();
    gain.connect(ctx.destination);
    gain.gain.value = 0.8;
    for (var i=0;i<nibbles.length;i++){
      (function(i){
        var n = nibbles[i];
        var osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = nibbleFreq(n);
        osc.connect(gain);
        osc.start(now + (i * symbolDuration / 1000));
        osc.stop(now + ((i+1) * symbolDuration / 1000));
      })(i);
    }
    // call done after last tone
    setTimeout(function(){
      ctx.close();
      if (onDone) onDone();
    }, nibbles.length * symbolDuration + 50);
  } catch(e) {
    log("Audio play failed: " + e);
    if (onDone) onDone();
  }
}

// Play full message (with start marker then nibbles then end marker)
function playMessageHex(hexStr, onDone) {
  // convert hex to nibble array (each hex char is a nibble 0..15)
  var nibbles = hexToNibbles(hexStr);
  // prepend a few marker nibbles (we use marker as special tone out of range: play marker tone via separate oscillator)
  // Instead of marker nibble we will play a burst at markerFreq for 250ms, then nibbles, then marker
  try {
    var ctx = new (window.AudioContext || window.webkitAudioContext)();
    var now = ctx.currentTime;
    var gain = ctx.createGain();
    gain.connect(ctx.destination);
    gain.gain.value = 0.8;
    // start marker
    var startOsc = ctx.createOscillator();
    startOsc.type = 'sine';
    startOsc.frequency.value = markerFreq;
    startOsc.connect(gain);
    startOsc.start(now);
    startOsc.stop(now + 0.25);
    // schedule nibble tones after start marker
    for (var i=0;i<nibbles.length;i++){
      (function(i){
        var n = nibbles[i];
        var osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = nibbleFreq(n);
        osc.connect(gain);
        var start = now + 0.25 + (i * symbolDuration / 1000);
        var end = start + (symbolDuration / 1000);
        osc.start(start);
        osc.stop(end);
      })(i);
    }
    // end marker after nibble sequence
    var totalDur = 0.25 + (nibbles.length * symbolDuration / 1000);
    var endOsc = ctx.createOscillator();
    endOsc.type = 'sine';
    endOsc.frequency.value = markerFreq;
    endOsc.connect(gain);
    endOsc.start(now + totalDur);
    endOsc.stop(now + totalDur + 0.25);
    setTimeout(function(){ ctx.close(); if (onDone) onDone(); }, (totalDur + 0.3)*1000);
  } catch(e) {
    log("Audio play error: " + e);
    if (onDone) onDone();
  }
}

// --- Receiver decode via Goertzel-ish approach ---
function createReceiver(onSymbol) {
  var ctx = new (window.AudioContext || window.webkitAudioContext)();
  var analyser = ctx.createAnalyser();
  analyser.fftSize = 2048;
  var bufferLen = analyser.fftSize;
  var dataArray = new Uint8Array(bufferLen);

  var freqs = [];
  for (var i=0;i<16;i++) freqs.push(nibbleFreq(i));
  // include marker as well
  freqs.push(markerFreq);

  var bins = freqs.map(function(f){
    return Math.round(f * analyser.fftSize / ctx.sampleRate);
  });

  var source = null;
  var listening = false;

  function startListening(stream) {
    source = ctx.createMediaStreamSource(stream);
    source.connect(analyser);
    listening = true;
    var symbolMs = symbolDuration;
    var interval = setInterval(function(){
      if (!listening) { clearInterval(interval); return; }
      analyser.getByteFrequencyData(dataArray);
      // find strongest frequency among our bins
      var bestIndex = -1;
      var bestVal = -1;
      for (var i=0;i<bins.length;i++){
        var idx = bins[i];
        var val = dataArray[idx] || 0;
        if (val > bestVal) { bestVal = val; bestIndex = i; }
      }
      // if marker freq is strong => marker
      if (bestVal > 120) { // threshold (tune)
        onSymbol(bestIndex, bestVal);
      } else {
        // nothing detected
        onSymbol(-1, bestVal);
      }
    }, symbolMs);
  }

  function stopListening(){
    listening = false;
    try { if (source) source.disconnect(); } catch(e){}
    try{ ctx.close(); } catch(e){}
  }

  return {start:startListening, stop:stopListening};
}

// --- WebRTC flow ---
document.getElementById('startCam').addEventListener('click', function(){
  // capture preview only (no offer yet)
  navigator.mediaDevices.getUserMedia({video:true,audio:false})
    .then(function(s){
      localStream = s;
      localVideo.srcObject = s;
      log("Camera preview started");
    }).catch(function(e){ log("Camera error: " + e); });
});

document.getElementById('createOffer').addEventListener('click', function(){
  if (!localStream) {
    log("Start camera first");
    return;
  }
  // Create PeerConnection, add tracks
  pc = new RTCPeerConnection();
  // Attach local tracks to pc
  for (var i=0;i<localStream.getTracks().length;i++){
    pc.addTrack(localStream.getTracks()[i], localStream);
  }
  log("PeerConnection created, creating offer...");
  pc.createOffer().then(function(offer){
    return pc.setLocalDescription(offer);
  }).then(function(){
    var offerSDP = pc.localDescription.sdp || JSON.stringify(pc.localDescription);
    var offerJSON = { type: pc.localDescription.type, sdp: pc.localDescription.sdp };
    var s = JSON.stringify(offerJSON);
    log("Offer created length: " + s.length + " chars. Encoding to audio...");
    // encode to hex and play audio
    var hex = strToHex(s);
    playMessageHex(hex, function(){ log("Offer audio finished playing. Now start receiver to wait for answer audio..."); });
    // also start listening for answer audio
    startListeningForAnswer();
  }).catch(function(err){ log("Offer error: " + err); });
});

var listeningReceiver = null;
var answerCapture = "";
var expectingAnswer = false;
function startListeningForAnswer() {
  expectingAnswer = true;
  navigator.mediaDevices.getUserMedia({audio:true, video:false})
    .then(function(stream){
      log("Listening for answer via mic (be ready)...");
      var recv = createReceiver(function(symIndex, strength){
        // symIndex -1 means nothing; if marker index is last index => marker detected
        if (!expectingAnswer) return;
        if (symIndex === -1) return;
        var markerIndex = 16; // last index in bins array
        if (symIndex === markerIndex) {
          // marker toggles start/end
          // simple strategy: flip capture mode when marker detected
          if (!answerCapture) {
            log("Start marker detected, begin capturing symbols...");
            answerCapture = "";
          } else {
            log("End marker detected, finishing capture...");
            expectingAnswer = false;
            recv.stop();
            // decoded -> hex string -> text
            try {
              var hex = answerCapture;
              var txt = hexToStr(hex);
              log("Decoded answer length: " + txt.length);
              decodedArea.value = txt;
              applyRemoteAnswer(txt);
            } catch(e) { log("Decode error: " + e); }
          }
          return;
        } else {
          // regular nibble 0..15
          if (symIndex >=0 && symIndex < 16) {
            var nib = symIndex;
            // append nibble as hex char
            answerCapture += nib.toString(16);
          }
        }
      });
      recv.start(stream);
      listeningReceiver = recv;
    })
    .catch(function(err){ log("Mic listening failed: " + err); });
}

// apply remote answer JSON text (string) to PeerConnection
function applyRemoteAnswer(txt) {
  try {
    var obj = JSON.parse(txt);
    pc.setRemoteDescription(new RTCSessionDescription(obj))
      .then(function(){ log("Remote answer applied. Connection should proceed (if ICE available)."); })
      .catch(function(err){ log("setRemoteDescription error: " + err); });
  } catch(e) {
    log("Invalid JSON from audio answer: " + e);
  }
}
</script>
</body>
</html>
